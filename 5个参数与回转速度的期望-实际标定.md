# 5个参数与回转速度的期望-实际标定

## 修改说明

| 代号   | 摘要                                                         | 等级 | 日期       |
| ------ | ------------------------------------------------------------ | ---- | ---------- |
| `TA01` | 液压标定禁用手柄后的波形幅度，对应回转速度，单位为 `0.01 deg/s`，**改为** `500`，（原用 `5` 误以为对应 `5 deg/s`）； | A    | 11\12\2024 |
| `TB02` | 线性回归参数，`par_linear_regression_intercept`，叠加 `500` 后，回转速度大于 `500`； | B    |            |
| `TB03` | 线性回归参数，`par_linear_regression_intercept` ，左右回转要分别加减； | B    |            |
| `TB04` | 线性回归参数，斜率输入缩小`1000`，保持4位有效数字，优先除`1000.0`，`(par_linear_regression_slope/1000.0)` | B    |            |
| `TB05` | 程序的使能按键，**增**左右手柄\|\|面板安全开关，临时退出波形，波形持续但不对外输出；**原**大灯按键，直接中断波形且输出`0`； | B    |            |
| `TC06` | 程序的自动退出行为受到灭灯行为干扰；                         | C    |            |
| `TA07` | 程序中断后，下次再进入时既不左转也不右转，应当添加 `if` 判断输出为 `0`，否则，可能保持之前的输出； | A    |            |
| `TQ08` | 使用 `retain` 变量在`global_retain_variables`，刷入程序后无需从显示器给值（`default`前缀变量，仅仅用于新车刷入）； | 待办 |            |
| `TR10` | 根据不同的回转速度-电流值关系，默认不再使用两个线性回归参数； | 要求 |            |
| `TZ11` | ~~为使得制动缸能落下，额外加1秒`T_timer+T#1000MS`，结尾置零`IF t > T_seconds THEN tangjinfeng_wave_value := 0; END_IF`~~依赖 `TA07`； | A    |            |
| `WR12` | 将线性回归前的指令速度 `x100` 发给`target_anti_slew_velocity`； | 要求 | 11\13\2024 |
| `WB13` | 根据转速自动 case 决定幅度，无需`par_waveform_amplitude_when_disable_joystick`； | B    |            |
| `WB14` | 特殊案例，参数化输入，占用24个参数`uint`，其中，**`k`** 取 `x10`，**`b`** 直接舍入取整； | B    |            |
| `HB15` | (*自动写参数20230314*)(*20241101 回转速度标定 by 唐金峰*)；  | B    | 11\14\2024 |
| `HB16` | 阀制动的平顺性 与 `limit` 的使用；阀制动时发送 `-0.2`，但给`target_anti_slew_velocity`为 `0`； | B    |            |
|        | 学习隐式枚举，`form : (zz, trii, sinn, stairr, trapee) := sinn;  (*波形 ID*)`； |      |            |
|        | 临时构建变量，`VAR_TEMP`，少用空间，但多了一次写操作。       |      |            |
| `FR17` | 台阶波形中步数选择增添为 10、16、20；                        | 要求 | 11\15\2024 |
| `SR18` | 增加梯形波形，最大速度显性与其它波形一致；使用 `ELSIF` 而不是 `ELSE IF`，后者嵌套有多个`END_IF`； | 要求 | 11\18\2024 |
| `UR19` | 波形 与 实际速度的补偿。前期测试分段累计衰减大，左右不一致；增跳变重置 `pid`，累计衰减至0.2；增分段放大设置 `pid` 的 `kp` 值。右回转比左回转小，0.75的 `kp`。 |      |            |
| `MB20` | 斜率跳变检测，仅仅检测斜率绝对值减小时的跳变；               |      | 12\04\2024 |

## 电流值-回转速度关系

- 回转速度单位为 `deg/s` ，需转换为 `0.01 deg/s`， `k` 要先除以 `100`。参数传入地址，要再 `x1000`，故直接 `x10`；

| `can_engine_speed` | amp           | 方向 | `k`                | `b`           |                                  | -1   |
| ------------------ | ------------- | ---- | ------------------ | ------------- | -------------------------------- | ---- |
| `900`              | `250  @[941]` | `l`  | `99.2  x10@[943]`  | `342  @[944]` | `无需参数 par_linear_regression` |      |
|                    |               | `r`  | `73.9  x10@[945]`  | `414  @[946]` | `无需参数`                       |      |
| `1000`             | `300  @[947]` | `l`  | `89.3  x10@[949]`  | `342  @[950]` | `无需参数`                       |      |
|                    |               | `r`  | `66.5   x10@[951]` | `414  @[952]` | `无需参数`                       |      |
| `1400`             | `400  @[953]` | `l`  | `63.8  x10@[955]`  | `342  @[956]` | `无需参数`                       |      |
|                    |               | `r`  | `47.5  x10@[957]`  | `414  @[958]` | `无需参数`                       |      |
| `1600`             | `500  @[959]` | `l`  | `55.8  x10@[961]`  | `342  @[962]` | `无需参数`                       |      |
|                    |               | `r`  | `41.6  x10@[963]`  | `414  @[964]` | `无需参数`                       |      |



## 参数

```pascal
(*20241101 回转速度标定 by 唐金峰*)
	par_waveform_amplitude_when_disable_joystick: UINT := 500; (*液压标定禁用手柄后的波形幅度*)
	par_waveform_period: UINT := 100;	                       (*液压标定禁用手柄后的波形时间，秒*)
	par_waveform_form : UINT := 2;                             (*液压标定禁用手柄后的波形形状，1为三角波，2为正弦波，3为台阶波*)
	par_linear_regression_slope : UINT := 1000;
	par_linear_regression_intercept : UINT := 300;
	par_special_amp1 : UINT;
	par_special_amp3 : UINT;
	par_special_amp5 : UINT;
	par_special_amp7 : UINT;
	par_special_regr_k1 : UINT;
	par_special_regr_k2 : UINT;
	par_special_regr_k3 : UINT;
	par_special_regr_k4 : UINT;
	par_special_regr_k5 : UINT;
	par_special_regr_k6 : UINT;
	par_special_regr_k7 : UINT;
	par_special_regr_k8 : UINT;
	par_special_regr_b1 : UINT;
	par_special_regr_b2 : UINT;
	par_special_regr_b3 : UINT;
	par_special_regr_b4 : UINT;
	par_special_regr_b5 : UINT;
	par_special_regr_b6 : UINT;
	par_special_regr_b7 : UINT;
	par_special_regr_b8 : UINT;  // (*20241101 回转速度标定 by 唐金峰*)



(*20241101 回转速度标定 by 唐金峰*)
	array_par_write[936]:=par_waveform_amplitude_when_disable_joystick;
	array_par_write[937]:=par_waveform_period;
	array_par_write[938]:=par_waveform_form;
	array_par_write[939]:=par_linear_regression_slope;
	array_par_write[940]:=par_linear_regression_intercept;
    array_par_write[941]:=par_special_amp1;
    array_par_write[943]:=par_special_regr_k1;  // 跳过942
    array_par_write[944]:=par_special_regr_b1;
    array_par_write[945]:=par_special_regr_k2;
    array_par_write[946]:=par_special_regr_b2;
    array_par_write[947]:=par_special_amp3;
    array_par_write[949]:=par_special_regr_k3;  // 跳过948
    array_par_write[950]:=par_special_regr_b3;
    array_par_write[951]:=par_special_regr_k4;
    array_par_write[952]:=par_special_regr_b4;
    array_par_write[953]:=par_special_amp5;
    array_par_write[955]:=par_special_regr_k5;  // 跳过954
    array_par_write[956]:=par_special_regr_b5;
    array_par_write[957]:=par_special_regr_k6;
    array_par_write[958]:=par_special_regr_b6;
    array_par_write[959]:=par_special_amp7;
    array_par_write[961]:=par_special_regr_k7;  // 跳过960
    array_par_write[962]:=par_special_regr_b7;
    array_par_write[963]:=par_special_regr_k8;
    array_par_write[964]:=par_special_regr_b8;  // (*20241101 回转速度标定 by 唐金峰*)



(*20241101 回转速度标定 by 唐金峰*)
	par_waveform_amplitude_when_disable_joystick :=array_par_read[936];
	par_waveform_period :=array_par_read[937];
	par_waveform_form :=array_par_read[938];
	par_linear_regression_slope :=array_par_read[939];
	par_linear_regression_intercept :=array_par_read[940];
    par_special_amp1 := array_par_read[941];
    par_special_regr_k1 := array_par_read[943];  // 跳过942
    par_special_regr_b1 := array_par_read[944];
    par_special_regr_k2 := array_par_read[945];
    par_special_regr_b2 := array_par_read[946];
    par_special_amp3 := array_par_read[947];
    par_special_regr_k3 := array_par_read[949];  // 跳过948
    par_special_regr_b3 := array_par_read[950];
    par_special_regr_k4 := array_par_read[951];
    par_special_regr_b4 := array_par_read[952];
    par_special_amp5 := array_par_read[953];
    par_special_regr_k5 := array_par_read[955];  // 跳过954
    par_special_regr_b5 := array_par_read[956];
    par_special_regr_k6 := array_par_read[957];
    par_special_regr_b6 := array_par_read[958];
    par_special_amp7 := array_par_read[959];
    par_special_regr_k7 := array_par_read[961];  // 跳过960
    par_special_regr_b7 := array_par_read[962];
    par_special_regr_k8 := array_par_read[963];
    par_special_regr_b8 := array_par_read[964];  // (*20241101 回转速度标定 by 唐金峰*)



(*20241101 回转速度标定 by 唐金峰*)
    array_default_par_set[941] := TO_UINT(250);
    array_default_par_set[943] := TO_UINT(87.75 * 10);
    array_default_par_set[944] := TO_UINT(374.65);
    array_default_par_set[945] := TO_UINT(73.39 * 10);
    array_default_par_set[946] := TO_UINT(401.88);

    array_default_par_set[947] := TO_UINT(300);
    array_default_par_set[949] := TO_UINT(80.16 * 10);
    array_default_par_set[950] := TO_UINT(364.93);
    array_default_par_set[951] := TO_UINT(64.1 * 10);
    array_default_par_set[952] := TO_UINT(408.41);

    array_default_par_set[953] := TO_UINT(400);
    array_default_par_set[955] := TO_UINT(68.37 * 10);
    array_default_par_set[956] := TO_UINT(323.64);
    array_default_par_set[957] := TO_UINT(48.89 * 10);
    array_default_par_set[958] := TO_UINT(415.54);

    array_default_par_set[959] := TO_UINT(500);
    array_default_par_set[961] := TO_UINT(63.97 * 10);
    array_default_par_set[962] := TO_UINT(306.22);
    array_default_par_set[963] := TO_UINT(42.23 * 10);
    array_default_par_set[964] := TO_UINT(430.17);  // (*20241101 回转速度标定 by 唐金峰*)



(*自动写参数20230314*)(*20241101 回转速度标定 by 唐金峰*)
array_max_length:=964;(*array_max_length的大小自己根据默认参数数组长度修改,如数组0-1000就填1000*)
IF INIT111 THEN
	NEW_Default_Par_AUTOWRITE_Enable:=TRUE;
	COUNT_STEP:=1;
	conut_auto_write:=941;
	INIT111:=FALSE;
END_IF
IF NEW_Default_Par_AUTOWRITE_Enable THEN
	COUNT_STEP:=COUNT_STEP+1;
	IF COUNT_STEP > 7 THEN (*第7个幸运周期*)
		conut_onecycle := 1;
		WHILE conut_auto_write<=array_max_length AND conut_onecycle<=25 DO
			IF array_default_par_set[conut_auto_write]>0 AND (array_par_read[conut_auto_write]=0 OR array_par_read[conut_auto_write]=65535)
				(*部分参数可能默认不是0，但实际调整至0,如功能配置参数、最低角度参数，需筛选掉*)
			AND (conut_auto_write<>220 AND  conut_auto_write<>237 AND conut_auto_write<>238 AND conut_auto_write<>239 AND conut_auto_write<>921) THEN(*新增的参数*)
				auto_write_value:=array_default_par_set[conut_auto_write];
				F_framwrite_4(ENABLE:=TRUE , DST:=conut_auto_write*2 , LEN:=2 , SRC:=ADR(auto_write_value) );  //更新内存变量
			ELSE(*代表不是新增的*)
				auto_write_value:=0;
			END_IF
			conut_auto_write:=conut_auto_write+1;
			conut_onecycle:=conut_onecycle+1;
		END_WHILE
	END_IF
	IF conut_auto_write>array_max_length THEN(*写完*)
		NEW_Default_Par_AUTOWRITE_Enable:=FALSE;
		enable_par_read:=TRUE;  // 下个周期读取内存，更新变量
		COUNT_STEP:=255;
	END_IF
END_IF  // (*20241101 回转速度标定 by 唐金峰*)
```

## 极值点检测

```pascal
FUNCTION_BLOCK change_rate_checkout
VAR_INPUT
	data_in : INT;
	count_delay : INT;
END_VAR
VAR_OUTPUT
	rate_out: INT;
	extreme_point: BOOL;
END_VAR
VAR
	count_max : INT := 52;
	mem : ARRAY[0..51] OF INT;
	x1, x2: INT;
	head : INT := 0;
	tail : INT := 0;
	overflow : BOOL := FALSE;
	rate : INT;
	ii : INT;
END_VAR

```

```pascal
x2 := x1;
x1 := data_in;
rate := x2 - x1;

mem[tail] := rate;
tail := (tail + 1) MOD count_max;
overflow S= (tail = count_max-1);
IF overflow THEN
	head := (tail + 1) MOD count_max;
END_IF

ii := tail+count_max-count_delay-1;
rate_out := mem[ii MOD count_max];
IF ABS(mem[(ii-1) MOD count_max] - mem[(ii+1) MOD count_max]) >= 23  THEN
	IF ABS(mem[(ii-1) MOD count_max]) > ABS(mem[(ii+1) MOD count_max]) THEN
		extreme_point := TRUE;
	ELSE
		extreme_point := FALSE;  // 仅考虑斜率绝对值减小时的跳变
	END_IF
ELSIF ABS(mem[(ii-1) MOD count_max]) < 5 AND ABS(mem[(ii+1) MOD count_max]) < 5 AND rate_out >= 23 THEN
	extreme_point := FALSE;  // 两个匀速阶段阶跃跳变
ELSE
	extreme_point := FALSE;
END_IF
```



## 波形生成

- 程序输出在定义时一般不用 `subrange`，可在后续添加 `limit` 限定。
- 回转不要过分依赖制动缸制动，充分利用阀制动。尽量缓慢动作。
- 制动缸提前在死区打开，当回转后，静止时，制动缸自动落下，类似汽车的手刹，防止溜破。

```pascal
PROGRAM wave
VAR
	TONInst : TON;
	PID_no_swing : PID_FIXCYCLE;
	TOFInst : TOF;
	T_seconds : REAL := 100; (*20的倍数*)
	T_timer : TIME;
	xVar : BOOL;
	//form : (zz, trii, sinn, stairr, trapee) := sinn;  (*波形 ID*)
	omega, t, t_n : REAL;
	triagnle, sine, stair, trapezoid, value_n, v_scale : REAL;
	N_step : UINT := 10;
	h_step : UINT;
	out_accumulate: REAL := 0.0;
	change: INT;
	checkout: change_rate_checkout;
	tau: REAL;
	slope_jump: BOOL;
	kp_base: REAL;
	kp_adjust: REAL;
	amplitude,k,b: REAL;
	tangjinfeng_wave_value_base: INT;
END_VAR
VAR_OUTPUT
	tangjinfeng_wave_value: INT;
END_VAR
VAR_TEMP

END_VAR
```

实现

```pascal
IF NOT GVL_tjf.tangjinfeng_test_mode THEN
	GVL_tjf.xkeep_send_r := FALSE;
	GVL_tjf.xkeep_send_l := FALSE;
ELSE
	GVL_tjf.xkeep_send_r S= Cabin_left_joystick_X_CON > 250;
	IF GVL_tjf.xkeep_send_r AND GVL_tjf.xkeep_send_l THEN
		GVL_tjf.xkeep_send_r := FALSE;
		GVL_tjf.xkeep_send_l := FALSE;
	END_IF
	IF GVL_tjf.xkeep_send_r THEN
		GVL_tjf.xkeep_send_l := FALSE;
	END_IF
	GVL_tjf.xkeep_send_l S= Cabin_left_joystick_X_CON < -250;
	IF GVL_tjf.xkeep_send_r AND GVL_tjf.xkeep_send_l THEN
		GVL_tjf.xkeep_send_r := FALSE;
		GVL_tjf.xkeep_send_l := FALSE;
	END_IF
	IF GVL_tjf.xkeep_send_l THEN
		GVL_tjf.xkeep_send_r := FALSE;
	END_IF
	IF TONInst.Q THEN
		GVL_tjf.xkeep_send_r := FALSE;
		GVL_tjf.xkeep_send_l := FALSE;
		xVar := TRUE;
	END_IF
	IF GVL_tjf.xkeep_send_r XOR  GVL_tjf.xkeep_send_l THEN
		xVar := FALSE;
	END_IF
	TOFInst(IN := TONInst.Q, PT := T#30S);
	IF xVar AND NOT GVL_tjf.xkeep_send_r AND NOT GVL_tjf.xkeep_send_l THEN
		GVL_tjf.tangjinfeng_test_mode R= NOT TOFInst.Q;
	END_IF
	IF NOT GVL_tjf.tangjinfeng_test_mode THEN
		xVar := FALSE;
		{IF defined (variable: switch_30_key5_M)}
			{info 'ZTC1300VS863 灭灯行为'}
			switch_30_key5_M := FALSE;
			(*采用第一行第5个按键，进入测试状态*)
			can_panel_deal_with.F16_keep_on_switch(
				input_keep_on:=TRUE,
				input_set_par_led:= 1,
				output_keep_on=> ,
				output_led_left=> ,
				output_led_mid=>switch_30_key5_M,
				output_led_right=> );  // 灭灯
		{ELSE}
			{info 'ZTC1300VS863 仿真测试'}
			;
		{END_IF}
	END_IF
END_IF

T_seconds := UINT_TO_REAL(par_waveform_period);
T_timer := REAL_TO_TIME(T_seconds*1000);
TONInst(IN := GVL_tjf.xkeep_send_r XOR GVL_tjf.xkeep_send_l, PT := T_timer);
t := TIME_TO_REAL(TONInst.ET)/1000;

{IF defined (variable: form)}
	{info 'form defined to new feature: Implicit_Enum'}
	par_waveform_form := TO_UINT(form);
{ELSE}
    {info 'form not defined'}
    ;
{END_IF}
CASE par_waveform_form OF
	1:
		IF t < T_seconds/2 THEN
			triagnle := t;
		ELSE
			triagnle := T_seconds - t;
		END_IF
		value_n := triagnle / T_seconds * 2;
	2:
		omega := 2*3.1415926/T_seconds;
		value_n := SIN( omega * t/2);
	3:
		h_step := TO_UINT(T_seconds / N_step);
		IF t < T_seconds/2 THEN
			stair := UINT_TO_REAL(TO_UINT(t) / h_step * h_step);
		ELSE
			stair := UINT_TO_REAL(TO_UINT(T_seconds) - TO_UINT(t) / h_step * h_step);
		END_IF
		value_n := stair / T_seconds * 2;
	4:
		t_n := t / T_seconds;
		IF t_n < 1.0/16 THEN
			trapezoid := 0;
		ELSIF t_n < 1.0/16*2 THEN
			trapezoid := 8*(t_n - 1.0/16);
		ELSIF t_n < 1.0/16*3 THEN
			trapezoid := 1.0/2;
		ELSIF t_n < 1.0/16*6 THEN
			trapezoid := 8.0/3*(t_n - 1.0*3/16) + 1.0/2;
		ELSIF t_n < 1.0/16*10 THEN
			trapezoid := 1.0;
		ELSIF t_n < 1.0/16*13 THEN
			trapezoid := 8.0/3*(-t_n + 1.0*13/16) + 1.0/2;	
		ELSIF t_n < 1.0/16*14 THEN
			trapezoid := 1.0/2;
		ELSIF t_n < 1.0/16*15 THEN
			trapezoid := 8*(-t_n + 1.0*15/16);
		ELSE
			trapezoid := 0;
		END_IF
		value_n := trapezoid;
	5:
		t_n := t / T_seconds;
		IF t_n < 1.0/16 THEN
			trapezoid := 0;
		ELSIF t_n < 1.0/16*6 THEN
			trapezoid := 3.2*(t_n - 1.0/16);
		ELSIF t_n < 1.0/16*10 THEN
			trapezoid := 1.0;
		ELSIF t_n < 1.0/16*15 THEN
			trapezoid := -3.2*(t_n - 1.0*15/16);
		ELSE
			trapezoid := 0;
		END_IF
		value_n := trapezoid;
	ELSE
		value_n := 0;
END_CASE

IF t < T_seconds THEN
	value_n := LIMIT(0,value_n,1);  // 适时地使用 LIMIT 函数，后面不再需要无尽无脑的 ABS 函数。
ELSE
	value_n := (T_seconds - t)*0.3;  // 阀制动，1s，降至落下制动缸，PT := T_timer + T#1000MS
END_IF


CASE can_engine_speed OF
	850..950:
		amplitude := par_special_amp1;
		IF GVL_tjf.xkeep_send_l THEN
			k := par_special_regr_k1/1000.0;
			b := par_special_regr_b1;
		END_IF
		IF GVL_tjf.xkeep_send_r THEN
			k := par_special_regr_k2/1000.0;
			b := par_special_regr_b2;
		END_IF
		N_step := 10;
	951..1050:
		amplitude := par_special_amp3;
		IF GVL_tjf.xkeep_send_l THEN
			k := par_special_regr_k3/1000.0;
			b := par_special_regr_b3;
		END_IF
		IF GVL_tjf.xkeep_send_r THEN
			k := par_special_regr_k4/1000.0;
			b := par_special_regr_b4;
		END_IF
		N_step := 10;
	1310..1490:
		amplitude := par_special_amp5;
		IF GVL_tjf.xkeep_send_l THEN
			k := par_special_regr_k5/1000.0;
			b := par_special_regr_b5;	
		END_IF
		IF GVL_tjf.xkeep_send_r THEN
			k := par_special_regr_k6/1000.0;
			b := par_special_regr_b6;	
		END_IF
		N_step := 16;
	1510..1690:
		amplitude := par_special_amp7;
		IF GVL_tjf.xkeep_send_l THEN
			k := par_special_regr_k7/1000.0;
			b := par_special_regr_b7;	
		END_IF
		IF GVL_tjf.xkeep_send_r THEN
			k := par_special_regr_k8/1000.0;
			b := par_special_regr_b8;
		END_IF
		N_step := 20;
	ELSE
		amplitude := par_waveform_amplitude_when_disable_joystick;
		k := par_linear_regression_slope/1000.0;
		b := par_linear_regression_intercept;
		N_step := 10;;
END_CASE


IF GVL_tjf.xkeep_send_l THEN
	v_scale := -value_n * amplitude;
	target_anti_slew_velocity := TO_INT(v_scale);  // pid 需要正负值，不可放在 if 后
	tangjinfeng_wave_value_base := REAL_TO_INT(v_scale * k - b);
END_IF
IF GVL_tjf.xkeep_send_r THEN
	v_scale := value_n * amplitude;
	target_anti_slew_velocity := TO_INT(v_scale);
	tangjinfeng_wave_value_base := REAL_TO_INT(v_scale * k + b);
END_IF
IF t > T_seconds THEN
	value_n := 0;  // 绕过斜率跳变检测
	target_anti_slew_velocity := 0;  // 阀制动，1s，提前置零，PT := T_timer + T#1000MS
END_IF
IF par_linear_regression_slope=0 THEN kp_base := 4.0/amplitude; ELSE kp_base := par_linear_regression_slope/1000.0; END_IF


IF Tx_184_enable THEN
	checkout(
		data_in := TO_INT(value_n*8.333*100*T_seconds/4),
		count_delay := 1,
		rate_out => change,
		extreme_point => slope_jump,
	); // *8.333 是 1000ms/120ms，*100*T_seconds/4 是基于三角波的规范化。
	IF slope_jump AND ABS(target_anti_slew_velocity) > 60 THEN
		out_accumulate := out_accumulate*0.2;
	END_IF
	CASE ABS(change) OF
		0..61:
			kp_adjust := kp_base;
		62..324:
			kp_adjust := 1.618*kp_base;
		ELSE
			kp_adjust := 2*kp_base;
	END_CASE
	PID_no_swing(
		ACTUAL := -anti_slew_velocity,
		SET_POINT := target_anti_slew_velocity,
		KP := kp_adjust, TN := 6.0, TV := 0,
		Y_MANUAL := 0, Y_OFFSET := 0,
		Y_MIN := -50, Y_MAX := 50,
		MANUAL := (t > T_seconds),
		RESET := NOT GVL_tjf.tangjinfeng_test_mode OR (slope_jump AND ABS(target_anti_slew_velocity)>60) OR xVar,  // 0期望不保持 RESET
		CYCLE := 0.12,
	);
	out_accumulate := out_accumulate + PID_no_swing.Y;
	out_accumulate := LIMIT(-200,out_accumulate,200);
END_IF
tangjinfeng_wave_value := tangjinfeng_wave_value_base + TO_INT(out_accumulate);  // 加还是减，it is a question.

IF NOT GVL_tjf.xkeep_send_l AND NOT GVL_tjf.xkeep_send_r THEN
	target_anti_slew_velocity := 0;  // 同波形变量输出，要记得置零
	out_accumulate := 0;
	tangjinfeng_wave_value := 0;
END_IF

```



```pascal
GVL_tjf.tangjinfeng_test_mode:=headlamp_steering_enable;  // (*20241101 回转速度标定 by 唐金峰*)
```

## 个人全局变量

```pascal
{attribute 'qualified_only'}
VAR_GLOBAL
	tangjinfeng_test_mode: BOOL;
	xkeep_send_r: BOOL;
	xkeep_send_l: BOOL;
	par_waveform_amplitude_when_disable_joystick: UINT;  (*液压标定禁用手柄后的波形幅度*)
	par_waveform_period: UINT;	                         (*液压标定禁用手柄后的波形时间，秒*)
	par_waveform_form : UINT;                            (*液压标定禁用手柄后的波形形状，1为三角波，2为正弦波，3为台阶波*)
	par_linear_regression_slope : UINT;
	par_linear_regression_intercept : UINT;
END_VAR
```
